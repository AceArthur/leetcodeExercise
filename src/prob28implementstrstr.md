# problem 28. Implement strStr()

[题目链接](https://leetcode.com/problems/implement-strstr/)

## 方法

字符串匹配，算法中的一个核心问题，算法导论中专门一章在讲这个，自然有必要好好做一做。

1. 暴力法

    最简单直接的方法。关键是，在算法导论中的习题部分，说明其实对于随机的字符串，暴力法的匹配次数大约为 `2(n-m+1)`, 其中`n`是字符串长度，`m`是pattern长度。这个我自己花了超过一个小时算了一下（数学太菜了...），在均匀分布的随机生成字符串下，应用概率公式、等比数列求和，错项相消，再用极限和单调性证明一个不等式，最后的确有此结果。

    老实说，在正常的字符串环境下，的确BF应该不会太差。

2. Rabin-Karp算法

    本质就是做信息指纹（是这么叫吗？），跟之前做过的把10个长度的碱基对编码成一个数字的思想是一样的。

    BF慢的原因就是需要循环匹配嘛，那么我把这个pattern长度的字符串编码成一个数字，再把相应长度的的待匹配字符串同样编码，一个数字匹配一次就好了。关键是，编码下一个字符子串时，可以使用简单的两个乘法、一个减法就能得到，因此认为继续编码的代价为O(1)，所以这样的代价就是`O(n-m+1)`次匹配，`O(m)`的编码时间。

    然而精确编码（每位的weight是`|alphabet|^p`, `alphabet`是字符集，p是位置下标，将数字值与weight相乘再相加，即是精确编码）在实际中难以做到——必然会溢出。因而就得取模！然而一旦取模，就和hash的情况一样，如果编码值不同，那么必然不同，但如果相同，也不能说就相同。说着还得加入额外的比较。取模运算还是比较有讲究，第一是需要知道模运算的性质，即`(a+b)%M = (a%M + b%M) %M ;` , `(a*b)%M = ((a%M)*(b%M))%M`;其二素数要估算得好，不溢出的情况下尽可能大，这样才能减少“碰撞”。

3. 自动机算法

    这个很厉害，根据pattern构建一个自动机，然后由此自动机依次读取每个字符，并从初始状态随着读入字符而做状态转移，如果到了终态，那么就是匹配上了，否则读取完后还没有到终态则字符串中不包含此模式。自动机是可以完成Regular Expression的匹配，所以匹配字面值自然没有问题。

    具体来说，形式化定义的自动机包含状态集，初始状态，非终结字符集，终结状态集，转移规则共5项。在字符串匹配的任务下，状态集就是由`pattern的长度 + 1`个状态构成的，可以直接取长度`{0, 1, 2, ..., Len}`为状态集。初始状态自然就是`0`。终结状态集只包含一个元素，即最后一个状态`{Len}`, 非终结字符集就是所有可能读入的字符，一般为了通用就取`256`(不过要是`wchar_t`可怎么办)，转移规则这里可以用一个矩阵，就跟邻接矩阵一样的，比如行表示非终结字符，列表示状态。

    时间复杂度上，在构建好自动机后，只需O(n)即可确定；构建自动机的时间，根据实现的不同会有所不同，naive的最坏情况是`O(Len^3 * charset_size)`, 不过在采用了KMP的类似做法后，能够变为 `O(Len * charset_size)`.

4. KMP算法

    KMP实在是精妙。




## 代码