# problem 28. Implement strStr()

[题目链接](https://leetcode.com/problems/implement-strstr/)

## 方法

字符串匹配，算法中的一个核心问题，算法导论中专门一章在讲这个，自然有必要好好做一做。

1. 暴力法

    最简单直接的方法。关键是，在算法导论中的习题部分，说明其实对于随机的字符串，暴力法的匹配次数大约为 `2(n-m+1)`, 其中`n`是字符串长度，`m`是pattern长度。这个我自己花了超过一个小时算了一下（数学太菜了...），在均匀分布的随机生成字符串下，应用概率公式、等比数列求和，错项相消，再用极限和单调性证明一个不等式，最后的确有此结果。

    老实说，在正常的字符串环境下，的确BF应该不会太差。

2. Rabin-Karp算法

    本质就是做信息指纹（是这么叫吗？），跟之前做过的把10个长度的碱基对编码成一个数字的思想是一样的。

    BF慢的原因就是需要循环匹配嘛，那么我把这个pattern长度的字符串编码成一个数字，再把相应长度的的待匹配字符串同样编码，一个数字匹配一次就好了。关键是，编码下一个字符子串时，可以使用简单的两个乘法、一个减法就能得到，因此认为继续编码的代价为O(1)，所以这样的代价就是`O(n-m+1)`次匹配，`O(m)`的编码时间。

    然而精确编码（每位的weight是`|alphabet|^p`, `alphabet`是字符集，p是位置下标，将数字值与weight相乘再相加，即是精确编码）在实际中难以做到——必然会溢出。因而就得取模！然而一旦取模，就和hash的情况一样，如果编码值不同，那么必然不同，但如果相同，也不能说就相同。说着还得加入额外的比较。取模运算还是比较有讲究，第一是需要知道模运算的性质，即`(a+b)%M = (a%M + b%M) %M ;` , `(a*b)%M = ((a%M)*(b%M))%M`;其二素数要估算得好，不溢出的情况下尽可能大，这样才能减少“碰撞”。

    


## 代码