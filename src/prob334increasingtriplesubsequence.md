###problem 3334. Increasing Triplet Subsequence

[link](https://leetcode.com/problems/increasing-triplet-subsequence/)

## 方法

每次看到题解时，我都要大问自己三声：草草草，自己怎么就想不到呢！！！

O(n)的时间复杂度，O(1)的空间复杂度。

题解中，使用了2个数，这里设a，b。

a表示的意思是，在已遍历的序列中，目前最小的数；

b表示的意思是[**关键点**]，在已遍历的序列中，满足 存在 x < b 且b是满足该条件的最小值！其中x的位置在b之前。

注意啊注意！b并不一定是第二小的值：假设序列 `[ 2 , 3, 3 , 3 , 1 , 5]` , 在遍历到1时刻前，a是2，b是3；在遍历到1时，a应该更新为1，但是b仍然应该是3，因为只有3是满足前面有小于它的数其3是满足此条件的最小值。

有些绕，反正核心就是：b是满足前面有一个比它小的数的。而且为了使以后找到的数能够满足大于b，这个b应该选择为满足此条件的最小值。

最后，看下实现的代码：

```C++
 for(int i = 0 ; i < nums.size() ; ++i)
        {
            int cur_num = nums[i] ;
            if(cur_num <= a){ a = cur_num ; }
            else if(cur_num <= b ) { b = cur_num ; }
            else { return true ; } 
        }
```

特别精妙有没有！NEAT！CLEVER！ 如果要更新b，则此时必然有一个数小于b，且要更新的数是满足此条件最小的！！！几行语句，如此难以说清楚的逻辑，阐述得明明白白。

代码是最好的语言。

前提是，代码要漂亮！！！

在此，向写出此代码的人报以崇敬... 

昨天搜题解时，看到一位同学的解题思路：

1. 先想到O(n^3)的暴力法

2. 再想到双向法，即建立两个长度为n序列，一个表示该位置的左边是否有比它小的，一个表示该位置的右边是否有比它大的。这两个数据结构只需前向、后向各扫描一遍，前向时记录最小值，后向记录最大值。如果 有一个位置左边有比它小，右边有比它大，那么就能够满足递增三序列。 这样O（n）时间，O(n)开销就能搞定。感觉这个方法也非常好！！ 想起了以前遇到过的分糖问题，以及双向LSTM....

3. 终极解法

一句话，怎么这么不聪明...

## 代码

```C++

```

