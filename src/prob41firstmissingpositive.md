# problem 41. First Missing Positive

[题目链接](https://leetcode.com/problems/first-missing-positive/)

## 方法

还是是刷题的感觉，没有细致的思考。

首先题面给的信息真的是很少的。第一个缺失的正数，其实就是说在正数序列1,2,3,4,... 中，找这个给定的未排序候选序列中，第一个缺失的值。

给定的序列中的值是任意值，负数、0、正数都有，因此我们面临的问题就是如何把这个序列与连续正数序列对应起来，然后以O(n)时间、常数空间把第一对应缺失的值找到。

这么理清一下，是不是能够想到方法——把序列中的每个数，根据它的值，放到其应该的位置上。所谓应该的位置，就是0上方1，1上放2，2上放3，等等...放完之后，我们只需要从0开始，检查当前值是否是该位置对应的值，如果不是，则必然是该位置对应的数就是第一个缺失的正数；如果全都是，那说明第一缺失的数是数组大小再+1。

接下来讨论，该如何把每个数都放到其正确的位置？其实这个思想在快排的划分、三色排序都有的——SWAP！从第0个位置开始，根据当前位置的值，把它放到应该在的位置；然后把它放到的那个位置的数放到0这里来。结束了吗？不，我们还得继续把新拿过来数再继续放到其正确的位置——这也是一个循环的过程。这个循环何时截止？直到当前拿过来的数，就是正确值、或者是一个不合法的值（非正数、大于数组的size）。然后，我们开始下一个位置的放置过程（其实，如果这个位置的放置是因为遇到非法值而停止的，那么可以直接返回当前位置应该对应值即可。这从实际上来说肯定更快。不过其对时间复杂度的结果没有影响）。

上述会有一个BUG——如果拿过来的值与交换的值一样怎么办？假设当前位置是0，值是4，那么我们该把这个4当到第4-1 = 3这个位置上去，然后把3这个位置的数拿过来！如果，3这个位置上的数也是4怎么办！！给定的序列可是根本没有限制说没有重复的！一个很好的解决办法是，把限制条件改为：当前位置的值与待交换位置的值相同，则停止。这样，首先上面的问题解决了。其次，如果当前位置已经放上了正确的值，那么其待交换位置也就是本身，所以也满足此条件。OK，很完美。

最后，时间复杂度为何是O(N)? 看起来不是两个for循环吗？ 其实平摊分析一下，你只需要把每个数都放到正确位置即可。为其代价O（1），所以总的就是O(N)了。

## 代码

```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        // copy from https://discuss.leetcode.com/topic/8293/my-short-c-solution-o-1-space-and-o-n-time
        size_t sz = nums.size();
        // swap, let every positive number in their right position
        for(size_t i = 0; i < sz; ++i)
        {
            while(nums[i] > 0 && nums[i] < sz && nums[i] != nums[nums[i] - 1]) // so smart
            {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for(size_t i = 0; i < sz; ++i)
        {
            if(nums[i] != i + 1 ){ return i + 1; }
        }
        // all in right position(no missing), return the size of num
        return sz + 1;
    }
};
```
