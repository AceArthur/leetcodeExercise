###problem 72 Edit Distance

[link](https://leetcode.com/problems/edit-distance/)

###方法

超级经典的 编辑距离 算法！！！

之前从来没有写过啊... 这次终于写了。出于对算法的崇敬,直接放弃看了解答，动态规划的过程还是非常简单和清晰的。

问题是将A字符串变为B字符串最少需要的操作数。操作包括在A中插入、替换以及删除字符。每个操作代价为1，编辑距离求最小的代价。

定义F[i\][j\]表示字符串A[0，i]和B[0,j]的最短编辑距离。

依然是递归的思想，与LCS相同，从后往前考虑：

1. 如果A[i]与B[j]字符相同，那么 F[i\][j] =  F[i-1\][j-1]

2. 如果不同，那么就必然需要做一种操作了，代价需要+1 ，此外，不同的代价对应的前向状态不同：

    1. 如果在A[i]之后的位置插入与B[j]相同的字符，那么前向状态为 F[i\][j-1]

    2. 如果将A[i]替换为B[j]，那么前向状态为 F[i-1\][j-1]

    3. 如果将A[i]处的字符删除，那么前向状态为 F[i-1\][j]

以上就写出了编辑距离的递推方程。

但是，在考虑初始条件时出现了问题... 

开始是按照惯性思维，F[0\][0]表示A中第一个字符和B中第一个字符的最小编辑距离，这是还勉强可以认为如果相等则为0，如果不等则替换，为1；

但是考虑F[k\][0]时就出现了问题——如果相等，前向状态是F[k-1\][-1] ? 如果不等，又怎么算？

当时就在想，是不是应该把0作为常规状态，将-1作为边界条件。

疑惑之下，看了题解，发现申请的空间是` (len1 + 1) x (len2 + 1)` ， 给的注释是`len1`个字符串，有`len1+1`个隔板！

不服，看了维基百科，发现确实如此！申请多一个空间，然后直接`F[k][0] = k` ， 纵向也一样。

这么一想，真是巧妙！！

不过理解为隔板前面的说法就模糊了，我觉得可以理解为 SOS —— start of sentence ， 在自然语言中也这么干的...

应该是经典方法，需要记住这些细节！

###代码

    ```c++
    class Solution {
    public:
        int minDistance(string word1, string word2) {
            int len1 = word1.size() ,
                len2 = word2.size() ;
            // use a SOS tag
            vector<vector<int>> S(len1 + 1 , vector<int>(len2 +1 , 0)) ;
            // init
            for(int j = 1 ; j <= len2 ; ++j) S[0][j] = j ;
            for(int i = 0 ; i <= len1 ; ++i) S[i][0] = i ;
            // dynamic programing
            for(int i = 1 ; i <= len1 ; ++i)
                for(int j = 1 ; j <= len2 ; ++j)
                {
                    char chr1 = word1[i-1] ,
                         chr2 = word2[j-1] ;
                    if(chr1 == chr2) S[i][j] = S[i-1][j-1] ;
                    else
                    {
                        S[i][j] = min( S[i-1][j] ,   // delete 
                                  min( S[i-1][j-1] , // replacce
                                       S[i][j-1]     // insert
                                                   )) + 1 ;
                    }
                }
            return S[len1][len2] ;
        }
    };
    ```


###最后

1. 因为是一行或一列接着算的，所以可以优化空间，只用一行或一列就可以了. 不过从来没有做过，这个也是很简单的事，没事可以改下

2. 维基百科上的有一个明显的不同，就是它的min是在4中情况下的最小值——把替换和相等的判断合并在一起，根据字符是否相等，设置两个子串比较位置同时向前移动的代价(0 或 1)，然后再加上另外两种方式。这么一想似乎也很有道理，甚至现在都有些怀疑在三种比较中去最小值会不会有些问题，会不会删除或插入操作再加上一个代价甚至比相等直接向前的代价都小？ 这个暂时没有想到证明的方法。不过最后测试通过，似乎从实验上证明其是不可能的？ 不确定啊..
.