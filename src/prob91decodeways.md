###problem 91 Decode Ways

[link](https://leetcode.com/problems/decode-ways/)

###方法

与经典的上楼梯问题类似。说起上楼梯的问题，犹记得高中考试时就考过，当时完全不知道还可以先写出递推公式，然后再求解。而当年辉哥可是直接就有了思路，真是差距巨大啊。

这道题相比上楼梯，多了条件的判断。

主要包括：

1. 如果当前字符是0，那么这个字符不能单独解码，所以只能和前一个字符结合起来解码。因此到此字符的方法数与到前两个字符的解码方法数相同。（如果前一个字符和当前字符合起来也不是合法的可解码字符，说明这个串错误）

2. 如果前一个字符和当前字符组合成的2位数不能被解码，即 `<10` 或 `>26` ， 那么当前字符就只能被单独解码，所以到此字符的方法数与到前一个字符的方法数相同。

3. 其他情况下，既可以将当前字符单独解码，也可以和前一个字符合起来解码，所以方法数就是前一个位置的方法和前两个位置方法数的和。

还是再解释下为什么递推关系成立（有时就迷惑了）：假设仅当前字符可解码，那么总的解码可能情况 就是到前一个字符的解码情况 加上对该字符的解码，所以方法数就等于到前一个字符的解码方法数。其他情况也类似了。

最后，关于非法字符串的情况：

1. 第一个字符是0

2. 包含00 , 30 , 40 , ... , 90等情况

非法情况是存在的，且返回0。（之前用assert...结果提示RE了,orz）


###代码
    
    ```c++
    class Solution {
    public:
        int numDecodings(string s) {
            unsigned len = s.length() ;
            if(0 == len) return 0 ;
            vector<int> N(len + 1 , 0) ;
            N[0] = 1 ; // 查看下面的解释
            //assert(s[0] != '0') ;
            if(s[0] == '0') return 0 ;
            N[1] = 1 ;
            for(unsigned i = 1 ; i < len ; ++i)
            {
                if(s[i] == '0') 
                {
                    //assert(s[i-1] >= '1' && s[i-1] <= '2') ;
                    if(s[i-1] == '0' || s[i-1] >= '3') return 0 ;
                    N[i+1] = N[i-2 + 1] ;
                }
                else
                {
                    int value = ( s[i-1]  - '0' ) * 10 + ( s[i] - '0' ) ;
                    if(value > 10 && value <= 26) N[i+1] = N[i-2+1] + N[i-1+1] ;
                    else N[i+1] = N[i-1+1] ;
                }
            }
            return N[len] ;
        }
    };
    ```

###OTHERS

首先，代码中用了一个N[0]这一个不存在的情况，这是仅仅是为了初始化N[2]，或者说为了从代码结构上良好地将初始条件N[2]包含进来。（之前想的时候是不包含N[0]的，这样逻辑更加清晰。在这种情况下，N[0]表示到第一个字符的方法数，N[1]表示到第2个字符的方法数。N[0]很好初始化，但是初始化N[1]就不得不做一些判断，而且这些判断是与循环中的判断几乎一致，所以最终为了代码的简洁性，加入了N[0]这么一个算是标志位的东西。代码简洁了，但是含义模糊了。这也算是一个TradeOff吧）

其次，下标写错了很多地方... 提交多次才正确... 写代码时的逻辑没有写这个的时候清晰。
